Still work in progress, some bugs noticed already that haven't been fixed (e.g. division doesn't work with second(or higher)-degree terms.
Not "cleaned up".
Note to self: make a type for polynomial!

Note to Elina: make suitable type(s) for terms as well. "Types" in plural because it could be beneficial to have separate types (inherited from a common base class) for constant terms and variable terms. And while we are on the subject of types, define one for a binary operation (i.e. an operation that takes exactly two operands) as well. But before considering any of this, study (binary) trees: what they are, how to construct one, how are they useful, various ways to traverse a tree structure just to give some suggestions. I put "binary" in parenthesis because binary tree is a special case of a tree data structure. As the name suggests, each node of a binary tree has at most two child nodes.

Now this is important: representation (meaning the way you choose to model the problem at hand) is almost everything. Find the right representation and a solution appears almost by itself. In this case - and many more to come - it means that the way user wants the data to be represented is very much different from the structures and data types that work best when the same data has to be molded to our will. To be more concrete, it is almost always best to think about the model first and worry about user interaction last. The "real world" is messy and full of imperfections. The transition from the real world to the idealized world of data structures marks a boundary after which one should be confident that all that remains are valid structures of data, objects, values, whatever the terminology is for the language currently in use. In the context of this assignment this means that parsing the user input into types that represent a polynomial should be the last concern - and the way user input consists only of strings is ill suited for describing the structure of a polynomial or event a single term. This is why you have almost identical methods for adding and subtracting and why the code contains so many deeply nested if-statements. 

I talked about "primitive obsession" and how it is a habit that we should wean ourselves off of it. You can just not learn that bad habit in the first place. In the domain of "business software" (meaning not embedded systems and such) the right question is always to ask "what kind of type would model this concept the best". When dealing with "raw" data, a string might very well be the correct choice. However if the data has any structure and you have to get some meaning out of it, you should quickly try to move from the messy raw data into more formal representation. 
