Still work in progress, some bugs noticed already that haven't been fixed (e.g. division doesn't work with second(or higher)-degree terms.
Not "cleaned up".
Note to self: make a type for polynomial!

Note to Elina: make suitable type(s) for terms as well. "Types" in plural because it could be beneficial to have separate types (inherited from a common base class) for constant terms and variable terms. And while we are on the subject of types, define one for a binary operation (i.e. an operation that takes exactly two operands) as well. These will be the four basic arithmetic operations (+,-,*,/). But before considering any of this, study (binary) trees: what they are, how to construct one, how are they useful, various ways to traverse a tree structure just to give some suggestions. I put "binary" in parenthesis because binary tree is a special case of a tree data structure. As the name suggests, each node of a binary tree has at most two child nodes.

Now this is important: representation (meaning the way you choose to model the problem at hand) is almost everything. Find the right representation and a solution appears almost by itself. In this case - and many more to come - it means that the way user wants the data to be represented is very much different from the structures and data types that work best when the same data has to be molded to our will. To be more concrete, it is almost always best to think about the model first and worry about user interaction last. The "real world" is messy and full of imperfections. The transition from the real world to the idealized world of data structures marks a boundary after which one should be confident that all that remains are valid structures of data, objects, values, whatever the terminology is for the language currently in use. In the context of this assignment this means that parsing the user input into types that represent a polynomial should be the last concern - and the way user input consists only of strings is ill suited for describing the structure of a polynomial or even a single term. This is why you have almost identical methods for adding and subtracting and why the code contains so many deeply nested if-statements. 

I talked about "primitive obsession" and how it is a habit that we should wean ourselves off of it. You can just not learn that bad habit in the first place. In the domain of "business software" (meaning not embedded systems and such) the right question is always to ask "what kind of type would model this concept the best". When dealing with "raw" data, a string might very well be the correct choice. However if the data has any structure and you have to get some meaning out of it, you should quickly try to move from the messy raw data into more formal representation. The fatal drawback of primitive values is that they do not - and can not - contain any additional information on the structure of their content. This applies especially to strings. Because of this lack of structure, passing strings around is risky business. One cannot give any assurances (at least not the kind a compiler can enforce) on the content of any particular string because by definition, a string can contain an arbitrary set of characters.

Vaihdan äidinkieleen niin en pääse piiloutumaan englantia puhuvan persoonan taakse. Ensiksi todettakoon että itse en olisi aikanaan saanut tehtyä tätä tehtävää ilman kämppäkaverin apua. Varsinkin olio-ohjelmointi ja oikeastaan ohjelmointi ylipäätään oli minulle niin uutta ettei voinut ajatellakaan minun tekevän mitään tällaista omin päin. Mutta sinä teit ja todettakoon että et ainakaan helpoimmalla mahdollisella tavalla. Ole siis tyytyväinen mutta vain hetken koska työstettävää on paljon.

Jos siis haluat jatkaa opettelua tämän toimeksiannon parissa niin suosittelen aluksi miettimään mitä vaatisi jos laskimeen pitäisi lisätä vaikkapa tuki useamman kirjaimen mittaisiin muuttujan nimiin, uusia laskutoimituksia (esim. neliöjuuri, kertoma, logaritmit), laskutoimitukset tarkoilla arvoilla (ts. murtoluvuilla). Tuntuuko helpolta, hankalalta? Oliko ylipäätään alkuperäisen tehtävän tikkiin saaminen tuskallista? 

Yksi ohjelmoijan mittatikku on miten mittavan ohjelman pystyy tuottamaan niin että lähdekoodi pysyy ylläpidettävänä ja ymmärrettävänä. Useimmalla meistä on kriittinen piste jonka jälkeen matkan varrella kertyneet pienet virheet ja väärät valinnat alkavat tehdä muutoksista yhä vaikeampia kunnes ohjelman lähdekoodia on lähes mahdoton muuttaa ilman että aiheuttaa tahattomia sivuvaikutuksia (joka muuten on oiva määritelmä bugille). 
